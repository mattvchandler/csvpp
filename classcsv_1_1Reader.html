<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>csvpp: csv::Reader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">csvpp
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
   <div id="projectbrief">CSV parsing / writing libraries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecsv.html">csv</a></li><li class="navelem"><a class="el" href="classcsv_1_1Reader.html">Reader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classcsv_1_1Reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">csv::Reader Class Reference<div class="ingroups"><a class="el" href="group__cpp.html">C++ library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Parses CSV data.  
 <a href="classcsv_1_1Reader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="csv_8hpp_source.html">csv.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for csv::Reader:</div>
<div class="dyncontent">
<div class="center"><img src="classcsv_1_1Reader__coll__graph.png" border="0" usemap="#acsv_1_1Reader_coll__map" alt="Collaboration graph"/></div>
<map name="acsv_1_1Reader_coll__map" id="acsv_1_1Reader_coll__map">
<area shape="rect" title="Parses CSV data." alt="" coords="25,109,124,136"/>
<area shape="rect" href="structcsv_1_1Reader_1_1input__string__t.html" title="Disambiguation tag type." alt="" coords="5,5,144,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcsv_1_1Reader_1_1input__string__t.html">input_string_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tag type.  <a href="structcsv_1_1Reader_1_1input__string__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader_1_1Iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over Rows in CSV data.  <a href="classcsv_1_1Reader_1_1Iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader_1_1Row.html">Row</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single row of CSV data.  <a href="classcsv_1_1Reader_1_1Row.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aef82b8a84c99d9e1efa8362a0beb3abc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#aef82b8a84c99d9e1efa8362a0beb3abc">Reader</a> (std::istream &amp;input_stream, const char delimiter=',', const char quote='&quot;', const bool lenient = false)</td></tr>
<tr class="memdesc:aef82b8a84c99d9e1efa8362a0beb3abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a std::istream for CSV parsing.  <a href="classcsv_1_1Reader.html#aef82b8a84c99d9e1efa8362a0beb3abc">More...</a><br /></td></tr>
<tr class="separator:aef82b8a84c99d9e1efa8362a0beb3abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b149c65fe52f11e81a491abbb2754c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#a70b149c65fe52f11e81a491abbb2754c">Reader</a> (const std::string &amp;filename, const char delimiter=',', const char quote='&quot;', const bool lenient = false)</td></tr>
<tr class="memdesc:a70b149c65fe52f11e81a491abbb2754c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file for CSV parsing.  <a href="classcsv_1_1Reader.html#a70b149c65fe52f11e81a491abbb2754c">More...</a><br /></td></tr>
<tr class="separator:a70b149c65fe52f11e81a491abbb2754c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8fa23dbf6e0566859bdb3c039ab17a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#a7d8fa23dbf6e0566859bdb3c039ab17a">Reader</a> (<a class="el" href="structcsv_1_1Reader_1_1input__string__t.html">input_string_t</a>, const std::string &amp;input_data, const char delimiter=',', const char quote='&quot;', const bool lenient = false)</td></tr>
<tr class="memdesc:a7d8fa23dbf6e0566859bdb3c039ab17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV from memory.  <a href="classcsv_1_1Reader.html#a7d8fa23dbf6e0566859bdb3c039ab17a">More...</a><br /></td></tr>
<tr class="separator:a7d8fa23dbf6e0566859bdb3c039ab17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88b096c68445697d23fa3f7816fe1d2"><td class="memItemLeft" align="right" valign="top"><a id="ae88b096c68445697d23fa3f7816fe1d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Reader</b> (const <a class="el" href="classcsv_1_1Reader.html">Reader</a> &amp;)=delete</td></tr>
<tr class="separator:ae88b096c68445697d23fa3f7816fe1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26d1063c30866a8e1f044bb9798a6df"><td class="memItemLeft" align="right" valign="top"><a id="ae26d1063c30866a8e1f044bb9798a6df"></a>
<a class="el" href="classcsv_1_1Reader.html">Reader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcsv_1_1Reader.html">Reader</a> &amp;)=delete</td></tr>
<tr class="separator:ae26d1063c30866a8e1f044bb9798a6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad94dcb7fab4a0017a16bbad06fce984"><td class="memItemLeft" align="right" valign="top"><a id="aad94dcb7fab4a0017a16bbad06fce984"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Reader</b> (<a class="el" href="classcsv_1_1Reader.html">Reader</a> &amp;&amp;)=default</td></tr>
<tr class="separator:aad94dcb7fab4a0017a16bbad06fce984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c057f7b5da4a09c8f0a12357816be4"><td class="memItemLeft" align="right" valign="top"><a id="ae6c057f7b5da4a09c8f0a12357816be4"></a>
<a class="el" href="classcsv_1_1Reader.html">Reader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classcsv_1_1Reader.html">Reader</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ae6c057f7b5da4a09c8f0a12357816be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587c5c520af0ad8cdd3d938b3b77586a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#a587c5c520af0ad8cdd3d938b3b77586a">end_of_row</a> () const</td></tr>
<tr class="memdesc:a587c5c520af0ad8cdd3d938b3b77586a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for end of input.  <a href="classcsv_1_1Reader.html#a587c5c520af0ad8cdd3d938b3b77586a">More...</a><br /></td></tr>
<tr class="separator:a587c5c520af0ad8cdd3d938b3b77586a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c1fcc304aa13ab71d773226bb74197"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#a34c1fcc304aa13ab71d773226bb74197">eof</a> () const</td></tr>
<tr class="memdesc:a34c1fcc304aa13ab71d773226bb74197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for end of row.  <a href="classcsv_1_1Reader.html#a34c1fcc304aa13ab71d773226bb74197">More...</a><br /></td></tr>
<tr class="separator:a34c1fcc304aa13ab71d773226bb74197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad119a7c5515af83671cc93329f853cde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#ad119a7c5515af83671cc93329f853cde">operator bool</a> ()</td></tr>
<tr class="separator:ad119a7c5515af83671cc93329f853cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcded84f1da3796379f7e03f34d04f09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#afcded84f1da3796379f7e03f34d04f09">set_delimiter</a> (const char delimiter)</td></tr>
<tr class="memdesc:afcded84f1da3796379f7e03f34d04f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the delimiter character.  <a href="classcsv_1_1Reader.html#afcded84f1da3796379f7e03f34d04f09">More...</a><br /></td></tr>
<tr class="separator:afcded84f1da3796379f7e03f34d04f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae113d6f5832fa970bc47cf33362c11fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#ae113d6f5832fa970bc47cf33362c11fd">set_quote</a> (const char quote)</td></tr>
<tr class="memdesc:ae113d6f5832fa970bc47cf33362c11fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the quote character.  <a href="classcsv_1_1Reader.html#ae113d6f5832fa970bc47cf33362c11fd">More...</a><br /></td></tr>
<tr class="separator:ae113d6f5832fa970bc47cf33362c11fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bff874b30739c86d8939d61393e69e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#ac1bff874b30739c86d8939d61393e69e">set_lenient</a> (const bool lenient)</td></tr>
<tr class="memdesc:ac1bff874b30739c86d8939d61393e69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable lenient parsing.  <a href="classcsv_1_1Reader.html#ac1bff874b30739c86d8939d61393e69e">More...</a><br /></td></tr>
<tr class="separator:ac1bff874b30739c86d8939d61393e69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0815ece012ec69f9ae21d5ef1b8cc050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsv_1_1Reader_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#a0815ece012ec69f9ae21d5ef1b8cc050">begin</a> ()</td></tr>
<tr class="separator:a0815ece012ec69f9ae21d5ef1b8cc050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7c26e2cd6552dc07bfca9f52a85b72"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#a6a7c26e2cd6552dc07bfca9f52a85b72">end</a> ()</td></tr>
<tr class="separator:a6a7c26e2cd6552dc07bfca9f52a85b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2ba331c23ca26906a30483d3a594d9"><td class="memTemplParams" colspan="2">template&lt;typename T  = std::string&gt; </td></tr>
<tr class="memitem:a5f2ba331c23ca26906a30483d3a594d9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#a5f2ba331c23ca26906a30483d3a594d9">read_field</a> ()</td></tr>
<tr class="memdesc:a5f2ba331c23ca26906a30483d3a594d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single field.  <a href="classcsv_1_1Reader.html#a5f2ba331c23ca26906a30483d3a594d9">More...</a><br /></td></tr>
<tr class="separator:a5f2ba331c23ca26906a30483d3a594d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69d7e1afe42eef2088bfc4281dc3463"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae69d7e1afe42eef2088bfc4281dc3463"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsv_1_1Reader.html">Reader</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#ae69d7e1afe42eef2088bfc4281dc3463">operator&gt;&gt;</a> (T &amp;data)</td></tr>
<tr class="memdesc:ae69d7e1afe42eef2088bfc4281dc3463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single field.  <a href="classcsv_1_1Reader.html#ae69d7e1afe42eef2088bfc4281dc3463">More...</a><br /></td></tr>
<tr class="separator:ae69d7e1afe42eef2088bfc4281dc3463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bd0a0c4c6c30d49b7f3942d6b383cc"><td class="memTemplParams" colspan="2">template&lt;typename ... Data&gt; </td></tr>
<tr class="memitem:a36bd0a0c4c6c30d49b7f3942d6b383cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#a36bd0a0c4c6c30d49b7f3942d6b383cc">read_v</a> (Data &amp;... data)</td></tr>
<tr class="memdesc:a36bd0a0c4c6c30d49b7f3942d6b383cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads fields into variadic arguments.  <a href="classcsv_1_1Reader.html#a36bd0a0c4c6c30d49b7f3942d6b383cc">More...</a><br /></td></tr>
<tr class="separator:a36bd0a0c4c6c30d49b7f3942d6b383cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ea8bb94eb3932f60ebffd13a92ff23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsv_1_1Reader_1_1Row.html">Row</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#a31ea8bb94eb3932f60ebffd13a92ff23">get_row</a> ()</td></tr>
<tr class="memdesc:a31ea8bb94eb3932f60ebffd13a92ff23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current <a class="el" href="classcsv_1_1Reader_1_1Row.html" title="Represents a single row of CSV data.">Row</a>.  <a href="classcsv_1_1Reader.html#a31ea8bb94eb3932f60ebffd13a92ff23">More...</a><br /></td></tr>
<tr class="separator:a31ea8bb94eb3932f60ebffd13a92ff23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75a186b5f119e6a2514b396ccbcd2d"><td class="memTemplParams" colspan="2">template&lt;typename T  = std::string, typename OutputIter &gt; </td></tr>
<tr class="memitem:a5f75a186b5f119e6a2514b396ccbcd2d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#a5f75a186b5f119e6a2514b396ccbcd2d">read_row</a> (OutputIter it)</td></tr>
<tr class="memdesc:a5f75a186b5f119e6a2514b396ccbcd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads current row into an output iterator.  <a href="classcsv_1_1Reader.html#a5f75a186b5f119e6a2514b396ccbcd2d">More...</a><br /></td></tr>
<tr class="separator:a5f75a186b5f119e6a2514b396ccbcd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec59f84fb2d41fb27bf4c3d3fd441da8"><td class="memTemplParams" colspan="2">template&lt;typename T  = std::string&gt; </td></tr>
<tr class="memitem:aec59f84fb2d41fb27bf4c3d3fd441da8"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#aec59f84fb2d41fb27bf4c3d3fd441da8">read_row_vec</a> ()</td></tr>
<tr class="memdesc:aec59f84fb2d41fb27bf4c3d3fd441da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads current row into a std::vector.  <a href="classcsv_1_1Reader.html#aec59f84fb2d41fb27bf4c3d3fd441da8">More...</a><br /></td></tr>
<tr class="separator:aec59f84fb2d41fb27bf4c3d3fd441da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc21f76811d8d20d09dee601d5d7a8e"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a8bc21f76811d8d20d09dee601d5d7a8e"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::tuple&lt; Args... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#a8bc21f76811d8d20d09dee601d5d7a8e">read_row_tuple</a> ()</td></tr>
<tr class="memdesc:a8bc21f76811d8d20d09dee601d5d7a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads current row into a tuple.  <a href="classcsv_1_1Reader.html#a8bc21f76811d8d20d09dee601d5d7a8e">More...</a><br /></td></tr>
<tr class="separator:a8bc21f76811d8d20d09dee601d5d7a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de1aeffb012082858d39dfcbfaee7f"><td class="memTemplParams" colspan="2">template&lt;typename T  = std::string&gt; </td></tr>
<tr class="memitem:ab0de1aeffb012082858d39dfcbfaee7f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#ab0de1aeffb012082858d39dfcbfaee7f">read_all</a> ()</td></tr>
<tr class="memdesc:ab0de1aeffb012082858d39dfcbfaee7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read entire CSV data into a vector of vectors.  <a href="classcsv_1_1Reader.html#ab0de1aeffb012082858d39dfcbfaee7f">More...</a><br /></td></tr>
<tr class="separator:ab0de1aeffb012082858d39dfcbfaee7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa16a7c9a322ae5a7425a6f1961c0eff3"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structcsv_1_1Reader_1_1input__string__t.html">input_string_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsv_1_1Reader.html#aa16a7c9a322ae5a7425a6f1961c0eff3">input_string</a> {}</td></tr>
<tr class="memdesc:aa16a7c9a322ae5a7425a6f1961c0eff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tag.  <a href="classcsv_1_1Reader.html#aa16a7c9a322ae5a7425a6f1961c0eff3">More...</a><br /></td></tr>
<tr class="separator:aa16a7c9a322ae5a7425a6f1961c0eff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parses CSV data. </p>
<p>By default, parses according to RFC 4180 rules, and throws a <a class="el" href="classcsv_1_1Parse__error.html" title="Parsing error.">Parse_error</a> when given non-conformant input. The field delimiter and quote characters may be changed, and there is a lenient parsing option to ignore violations.</p>
<p>Blank rows are ignored and skipped over.</p>
<p>Most methods operate on rows, but some read field-by-field. Mixing row-wise and field-wise methods is not recommended, but is possible. Row-wise methods will act as if the current position is the start of a row, regardless of any fields that have been read from the current row so far. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aef82b8a84c99d9e1efa8362a0beb3abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef82b8a84c99d9e1efa8362a0beb3abc">&#9670;&nbsp;</a></span>Reader() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csv::Reader::Reader </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>','</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>quote</em> = <code>'&quot;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a std::istream for CSV parsing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_stream</td><td>std::istream to read from </td></tr>
    <tr><td class="paramname">delimiter</td><td>Delimiter character </td></tr>
    <tr><td class="paramname">quote</td><td>Quote character </td></tr>
    <tr><td class="paramname">lenient</td><td>Enable lenient parsing (will attempt to read past syntax errors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><code>input_stream</code> must not be destroyed or read from during the lifetime of this <a class="el" href="classcsv_1_1Reader.html" title="Parses CSV data.">Reader</a> </dd></dl>

</div>
</div>
<a id="a70b149c65fe52f11e81a491abbb2754c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b149c65fe52f11e81a491abbb2754c">&#9670;&nbsp;</a></span>Reader() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csv::Reader::Reader </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>','</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>quote</em> = <code>'&quot;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a file for CSV parsing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path to a file to parse </td></tr>
    <tr><td class="paramname">delimiter</td><td>Delimiter character </td></tr>
    <tr><td class="paramname">quote</td><td>Quote character </td></tr>
    <tr><td class="paramname">lenient</td><td>Enable lenient parsing (will attempt to read past syntax errors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcsv_1_1IO__error.html" title="IO error.">IO_error</a></td><td>if there is an error opening the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d8fa23dbf6e0566859bdb3c039ab17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8fa23dbf6e0566859bdb3c039ab17a">&#9670;&nbsp;</a></span>Reader() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csv::Reader::Reader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcsv_1_1Reader_1_1input__string__t.html">input_string_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>','</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>quote</em> = <code>'&quot;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>lenient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV from memory. </p>
<p>Use <a class="el" href="classcsv_1_1Reader.html#aa16a7c9a322ae5a7425a6f1961c0eff3" title="Disambiguation tag.">Reader::input_string</a> to distinguish this constructor from the constructor accepting a filename </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_data</td><td><code>std::string</code> containing CSV to parse </td></tr>
    <tr><td class="paramname">delimiter</td><td>Delimiter character </td></tr>
    <tr><td class="paramname">quote</td><td>Quote character </td></tr>
    <tr><td class="paramname">lenient</td><td>Enable lenient parsing (will attempt to read past syntax errors) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0815ece012ec69f9ae21d5ef1b8cc050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0815ece012ec69f9ae21d5ef1b8cc050">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsv_1_1Reader_1_1Iterator.html">Iterator</a> csv::Reader::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsv_1_1Reader_1_1Iterator.html" title="Iterates over Rows in CSV data.">Iterator</a> to current row </dd></dl>

</div>
</div>
<a id="a6a7c26e2cd6552dc07bfca9f52a85b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7c26e2cd6552dc07bfca9f52a85b72">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto csv::Reader::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsv_1_1Reader_1_1Iterator.html" title="Iterates over Rows in CSV data.">Iterator</a> to end of CSV data </dd></dl>

</div>
</div>
<a id="a587c5c520af0ad8cdd3d938b3b77586a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587c5c520af0ad8cdd3d938b3b77586a">&#9670;&nbsp;</a></span>end_of_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csv::Reader::end_of_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for end of input. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the last field in the row has been read </dd></dl>

</div>
</div>
<a id="a34c1fcc304aa13ab71d773226bb74197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c1fcc304aa13ab71d773226bb74197">&#9670;&nbsp;</a></span>eof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csv::Reader::eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for end of row. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if no fields remain in the current row </dd></dl>

</div>
</div>
<a id="a31ea8bb94eb3932f60ebffd13a92ff23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ea8bb94eb3932f60ebffd13a92ff23">&#9670;&nbsp;</a></span>get_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsv_1_1Reader_1_1Row.html">Row</a> csv::Reader::get_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current <a class="el" href="classcsv_1_1Reader_1_1Row.html" title="Represents a single row of CSV data.">Row</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsv_1_1Reader_1_1Row.html" title="Represents a single row of CSV data.">Row</a> object for the current row </dd></dl>

</div>
</div>
<a id="ad119a7c5515af83671cc93329f853cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad119a7c5515af83671cc93329f853cde">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csv::Reader::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there is more data to be read </dd></dl>

</div>
</div>
<a id="ae69d7e1afe42eef2088bfc4281dc3463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69d7e1afe42eef2088bfc4281dc3463">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsv_1_1Reader.html">Reader</a>&amp; csv::Reader::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single field. </p>
<p>Check <a class="el" href="classcsv_1_1Reader.html#a587c5c520af0ad8cdd3d938b3b77586a" title="Check for end of input.">end_of_row()</a> to see if this is the last field in the current row </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Variable to to write field to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This <a class="el" href="classcsv_1_1Reader.html" title="Parses CSV data.">Reader</a> object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcsv_1_1Parse__error.html" title="Parsing error.">Parse_error</a></td><td>if error parsing field (<em>only when not parsing in lenient mode</em>) </td></tr>
    <tr><td class="paramname"><a class="el" href="classcsv_1_1IO__error.html" title="IO error.">IO_error</a></td><td>if error reading CSV data </td></tr>
    <tr><td class="paramname"><a class="el" href="structcsv_1_1Type__conversion__error.html" title="Type conversion error.">Type_conversion_error</a></td><td>if error converting to type T. Caller may call this again with a different type to try again </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0de1aeffb012082858d39dfcbfaee7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0de1aeffb012082858d39dfcbfaee7f">&#9670;&nbsp;</a></span>read_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;T&gt; &gt; csv::Reader::read_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read entire CSV data into a vector of vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to convert fields to. Defaults to std::string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2D vector of CSV data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcsv_1_1Parse__error.html" title="Parsing error.">Parse_error</a></td><td>if error parsing field (<em>only when not parsing in lenient mode</em>) </td></tr>
    <tr><td class="paramname"><a class="el" href="classcsv_1_1IO__error.html" title="IO error.">IO_error</a></td><td>if error reading CSV data </td></tr>
    <tr><td class="paramname"><a class="el" href="structcsv_1_1Type__conversion__error.html" title="Type conversion error.">Type_conversion_error</a></td><td>if error converting to type T </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f2ba331c23ca26906a30483d3a594d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2ba331c23ca26906a30483d3a594d9">&#9670;&nbsp;</a></span>read_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T csv::Reader::read_field </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single field. </p>
<p>Check <a class="el" href="classcsv_1_1Reader.html#a587c5c520af0ad8cdd3d938b3b77586a" title="Check for end of input.">end_of_row()</a> to see if this is the last field in the current row </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to convert fields to. Defaults to std::string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next field from the row, or a default-initialized object if past the end of the input data </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcsv_1_1Parse__error.html" title="Parsing error.">Parse_error</a></td><td>if error parsing field (<em>only when not parsing in lenient mode</em>) </td></tr>
    <tr><td class="paramname"><a class="el" href="classcsv_1_1IO__error.html" title="IO error.">IO_error</a></td><td>if error reading CSV data </td></tr>
    <tr><td class="paramname"><a class="el" href="structcsv_1_1Type__conversion__error.html" title="Type conversion error.">Type_conversion_error</a></td><td>if error converting to type T. Caller may call this again with a different type to try again </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f75a186b5f119e6a2514b396ccbcd2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f75a186b5f119e6a2514b396ccbcd2d">&#9670;&nbsp;</a></span>read_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = std::string, typename OutputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csv::Reader::read_row </td>
          <td>(</td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads current row into an output iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to convert fields to. Defaults to std::string </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>An output iterator to receive the row data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if this is the last row </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcsv_1_1Parse__error.html" title="Parsing error.">Parse_error</a></td><td>if error parsing field (<em>only when not parsing in lenient mode</em>) </td></tr>
    <tr><td class="paramname"><a class="el" href="classcsv_1_1IO__error.html" title="IO error.">IO_error</a></td><td>if error reading CSV data </td></tr>
    <tr><td class="paramname"><a class="el" href="structcsv_1_1Type__conversion__error.html" title="Type conversion error.">Type_conversion_error</a></td><td>if error converting to type T </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bc21f76811d8d20d09dee601d5d7a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc21f76811d8d20d09dee601d5d7a8e">&#9670;&nbsp;</a></span>read_row_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::tuple&lt;Args...&gt; &gt; csv::Reader::read_row_tuple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads current row into a tuple. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>types to convert fields to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple containing the fields from the row or empty optional if no rows remain. If Args contains more elements than there are fields in the row, the remaining elements of the tuple will be default initialized </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcsv_1_1Parse__error.html" title="Parsing error.">Parse_error</a></td><td>if error parsing field (<em>only when not parsing in lenient mode</em>) </td></tr>
    <tr><td class="paramname"><a class="el" href="classcsv_1_1IO__error.html" title="IO error.">IO_error</a></td><td>if error reading CSV data </td></tr>
    <tr><td class="paramname"><a class="el" href="structcsv_1_1Type__conversion__error.html" title="Type conversion error.">Type_conversion_error</a></td><td>if error converting to specified types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec59f84fb2d41fb27bf4c3d3fd441da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec59f84fb2d41fb27bf4c3d3fd441da8">&#9670;&nbsp;</a></span>read_row_vec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;T&gt; &gt; csv::Reader::read_row_vec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads current row into a std::vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to convert fields to. Defaults to std::string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector containing the fields from the row or empty optional if no rows remain </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcsv_1_1Parse__error.html" title="Parsing error.">Parse_error</a></td><td>if error parsing field (<em>only when not parsing in lenient mode</em>) </td></tr>
    <tr><td class="paramname"><a class="el" href="classcsv_1_1IO__error.html" title="IO error.">IO_error</a></td><td>if error reading CSV data </td></tr>
    <tr><td class="paramname"><a class="el" href="structcsv_1_1Type__conversion__error.html" title="Type conversion error.">Type_conversion_error</a></td><td>if error converting to type T </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36bd0a0c4c6c30d49b7f3942d6b383cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bd0a0c4c6c30d49b7f3942d6b383cc">&#9670;&nbsp;</a></span>read_v()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Data&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csv::Reader::read_v </td>
          <td>(</td>
          <td class="paramtype">Data &amp;...&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads fields into variadic arguments. </p>
<dl class="section warning"><dt>Warning</dt><dd>This may be used to fields from multiple rows at a time. Use with caution if the number of fields per row is not known beforehand. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Variables to read into. If more parameters are passed than there are fields remaining, the remaining parameters will be default initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcsv_1_1Parse__error.html" title="Parsing error.">Parse_error</a></td><td>if error parsing field (<em>only when not parsing in lenient mode</em>) </td></tr>
    <tr><td class="paramname"><a class="el" href="classcsv_1_1IO__error.html" title="IO error.">IO_error</a></td><td>if error reading CSV data </td></tr>
    <tr><td class="paramname"><a class="el" href="structcsv_1_1Type__conversion__error.html" title="Type conversion error.">Type_conversion_error</a></td><td>if error converting to specified types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcded84f1da3796379f7e03f34d04f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcded84f1da3796379f7e03f34d04f09">&#9670;&nbsp;</a></span>set_delimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csv::Reader::set_delimiter </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the delimiter character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>New delimiter character </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1bff874b30739c86d8939d61393e69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bff874b30739c86d8939d61393e69e">&#9670;&nbsp;</a></span>set_lenient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csv::Reader::set_lenient </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>lenient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable / disable lenient parsing. </p>
<p>Lenient parsing will attempt to ignore syntax errors in CSV input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lenient</td><td><code>true</code> for lenient parsing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae113d6f5832fa970bc47cf33362c11fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae113d6f5832fa970bc47cf33362c11fd">&#9670;&nbsp;</a></span>set_quote()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csv::Reader::set_quote </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>quote</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the quote character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quote</td><td>New quote character </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa16a7c9a322ae5a7425a6f1961c0eff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16a7c9a322ae5a7425a6f1961c0eff3">&#9670;&nbsp;</a></span>input_string</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structcsv_1_1Reader_1_1input__string__t.html">input_string_t</a> csv::Reader::input_string {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disambiguation tag. </p>
<p>Distinguishes opening a <a class="el" href="classcsv_1_1Reader.html" title="Parses CSV data.">Reader</a> with a filename from opening a <a class="el" href="classcsv_1_1Reader.html" title="Parses CSV data.">Reader</a> with a string </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/matt/Dropbox/Programming/csvpp/include/csvpp/<a class="el" href="csv_8hpp_source.html">csv.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
